<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>Endless Bouncer</title>
  <link rel="stylesheet" href="style.css">
  <link rel="icon" href="gameIcon.PNG">
</head>

<body>
  <div id="gameContainer">
    <div id="scoreDisplay">Score: 0</div>
    <div id="character"></div>
    <div id="gameOverScreen">
        <h2>Game Over</h2>
        <p id="finalScore">Your Score: 0</p>
        <button id="restartButton">Restart</button>
    </div>
  </div>

  <!-- ðŸŽµ AUDIO ELEMENTS ADDED -->
  <audio id="jumpSound" src="assets/audio/jump.mp3" preload="auto"></audio>
  <audio id="landSound" src="assets/audio/land.mp3" preload="auto"></audio>
  <audio id="bgm" src="assets/audio/bgm.mp3" preload="auto" loop></audio>

  <script>
    const container = document.getElementById("gameContainer");
    const character = document.getElementById("character");
    const scoreDisplay = document.getElementById("scoreDisplay");
    const gameOverScreen = document.getElementById("gameOverScreen");
    const finalScoreDisplay = document.getElementById("finalScore");
    const restartButton = document.getElementById("restartButton");

    // ðŸŽµ AUDIO REFERENCES
    const jumpSound = document.getElementById("jumpSound");
    const landSound = document.getElementById("landSound");
    const bgm = document.getElementById("bgm");

    // --- GAME CONSTANTS ---
    const GRAVITY = 0.8;
    const MAX_JUMP_POWER = 22;
    const MIN_JUMP_POWER = 6;
    const CHARGE_SPEED = 1.5;
    const HORIZONTAL_SPEED = 7;
    const WALL_BOUNCE_DAMPING = 0.5;
    const GROUND_FRICTION = 0.1;
    const CHARACTER_WIDTH = 50;
    const CHARACTER_HEIGHT = 50;
    const BRICK_WIDTH = 80;
    const BRICK_HEIGHT = 15;
    const TOTAL_BRICKS = 8;
    const SCROLL_THRESHOLD_TOP = window.innerHeight / 2.5;

    // --- GAME STATE ---
    let positionX, positionY, velocityX, velocityY;
    let isCharging, jumpPower, jumpDirection;
    let isJumping;
    let chargeTimer;
    let score, highestY;
    let bricks = [];
    let gameState = 'playing'; // 'playing' or 'gameOver'

    function resetGame() {
        // Reset variables
        positionX = container.clientWidth / 2 - CHARACTER_WIDTH / 2;
        positionY = container.clientHeight - CHARACTER_HEIGHT - 50;
        velocityX = 0;
        velocityY = 0;
        isCharging = false;
        isJumping = false;
        jumpPower = MIN_JUMP_POWER;
        jumpDirection = 0;
        score = 0;
        highestY = positionY;

        // Reset display
        scoreDisplay.textContent = "Score: 0";
        character.style.left = positionX + "px";
        character.style.top = positionY + "px";
        updateChargeIndicator(0);

        // Hide game over screen
        gameOverScreen.style.display = 'none';

        // Clear existing bricks and create new ones
        bricks.forEach(brick => brick.remove());
        bricks = [];
        createInitialBricks();

        // Start game
        gameState = 'playing';
        bgm.currentTime = 0; // ðŸŽµ Restart music
        bgm.play().catch(() => {}); // Catch autoplay restrictions
        requestAnimationFrame(gameLoop);
    }

    function createInitialBricks() {
        createBrick(container.clientWidth / 2 - BRICK_WIDTH / 2, container.clientHeight - 50);
        for (let i = 0; i < TOTAL_BRICKS; i++) {
            createBrick(
                Math.random() * (container.clientWidth - BRICK_WIDTH),
                container.clientHeight - 150 - (i * 100)
            );
        }
    }

    function createBrick(x, y) {
        const brick = document.createElement("div");
        brick.className = "brick";
        brick.style.left = x + "px";
        brick.style.top = y + "px";
        container.appendChild(brick);
        bricks.push(brick);
    }
    
    // --- JUMP MECHANICS ---
    function startCharge(direction) {
        if (isJumping || isCharging) return;
        
        isCharging = true;
        jumpDirection = direction;
        jumpPower = MIN_JUMP_POWER;

        chargeTimer = setInterval(() => {
            if (jumpPower < MAX_JUMP_POWER) {
                jumpPower += CHARGE_SPEED;
            }
            updateChargeIndicator(jumpPower);
        }, 20);
    }

    function releaseJump() {
        if (!isCharging) return;

        velocityX = HORIZONTAL_SPEED * jumpDirection;
        velocityY = -jumpPower;
        isCharging = false;
        isJumping = true;
        clearInterval(chargeTimer);
        updateChargeIndicator(0);

        // ðŸŽµ Play jump sound
        jumpSound.currentTime = 0;
        jumpSound.play().catch(() => {});
    }
    
    function updateChargeIndicator(power) {
        const chargeRatio = Math.min((power - MIN_JUMP_POWER) / (MAX_JUMP_POWER - MIN_JUMP_POWER), 1);
        const color = `rgb(${255 * chargeRatio}, ${255 * (1 - chargeRatio)}, 0)`;
        character.style.setProperty('--eye-color', color);
        character.style.background = `
            conic-gradient(from 90deg, var(--eye-color, #292A37), var(--eye-color, #292A37)),
            conic-gradient(from 90deg, var(--eye-color, #292A37), var(--eye-color, #292A37)),
            conic-gradient(ghostwhite, ghostwhite)`;
        character.style.backgroundSize = '7px 15px, 7px 15px, 50px 50px';
        character.style.backgroundPosition = '12px 10px, 31px 10px, 0 0';
        character.style.backgroundRepeat = 'no-repeat';
    }

    // --- INPUT HANDLERS ---
    container.addEventListener("touchstart", (e) => {
        e.preventDefault();
        const touchX = e.touches[0].clientX;
        const direction = touchX < container.clientWidth / 2 ? -1 : 1;
        startCharge(direction);
    }, { passive: false });

    container.addEventListener("touchend", (e) => {
        e.preventDefault();
        releaseJump();
    });

    window.addEventListener('keydown', (e) => {
        if (isJumping || isCharging) return; 
        if (e.key === 'ArrowLeft') startCharge(-1);
        else if (e.key === 'ArrowRight') startCharge(1);
        else if (e.key === ' ' || e.key === 'ArrowUp') startCharge(0);
    });

    window.addEventListener('keyup', (e) => {
        if (isCharging && (e.key === ' ' || e.key === 'ArrowUp' || e.key === 'ArrowLeft' || e.key === 'ArrowRight')) {
            releaseJump();
        }
    });

    // --- COLLISION & PHYSICS ---
    function checkCollisions() {
        for (const brick of bricks) {
            const brickTop = brick.offsetTop;
            const brickLeft = brick.offsetLeft;

            if (
                velocityY > 0 &&
                positionY + CHARACTER_HEIGHT >= brickTop &&
                positionY + CHARACTER_HEIGHT <= brickTop + BRICK_HEIGHT &&
                positionX + CHARACTER_WIDTH > brickLeft &&
                positionX < brickLeft + BRICK_WIDTH
            ) {
                if (isJumping) {
                    score++;
                    scoreDisplay.textContent = "Score: " + score;

                    // ðŸŽµ Play land sound
                    landSound.currentTime = 0;
                    landSound.play().catch(() => {});
                }

                positionY = brickTop - CHARACTER_HEIGHT;
                velocityY = 0;
                isJumping = false;
                velocityX *= GROUND_FRICTION;
                if (Math.abs(velocityX) < 0.1) velocityX = 0;
                return;
            }
        }

        if (positionY >= container.clientHeight - CHARACTER_HEIGHT) {
            positionY = container.clientHeight - CHARACTER_HEIGHT;
            velocityY = 0;
            isJumping = false;
            velocityX *= GROUND_FRICTION;
            if (Math.abs(velocityX) < 0.1) velocityX = 0;

            // ðŸŽµ Play land sound on ground hit
            landSound.currentTime = 0;
            landSound.play().catch(() => {});
        }
    }

    function endGame() {
        gameState = 'gameOver';
        finalScoreDisplay.textContent = `Your Score: ${score}`;
        gameOverScreen.style.display = 'flex';
        bgm.pause(); // ðŸŽµ Stop background music
    }

    // --- MAIN GAME LOOP ---
    function gameLoop() {
        if (gameState !== 'playing') return;
        velocityY += GRAVITY;
        positionX += velocityX;
        positionY += velocityY;

        if (positionX < 0) {
            positionX = 0;
            velocityX *= -WALL_BOUNCE_DAMPING;
        } else if (positionX > container.clientWidth - CHARACTER_WIDTH) {
            positionX = container.clientWidth - CHARACTER_WIDTH;
            velocityX *= -WALL_BOUNCE_DAMPING;
        }

        checkCollisions();

        if (positionY < SCROLL_THRESHOLD_TOP) {
            const scrollAmount = SCROLL_THRESHOLD_TOP - positionY;
            positionY += scrollAmount;
            bricks.forEach(brick => {
                brick.style.top = (brick.offsetTop + scrollAmount) + "px";
            });
            highestY -= scrollAmount;
        }

        character.style.left = positionX + "px";
        character.style.top = positionY + "px";

        bricks.forEach(brick => {
            if (brick.offsetTop > container.clientHeight) {
                brick.style.left = Math.random() * (container.clientWidth - BRICK_WIDTH) + 'px';
                brick.style.top = (brick.offsetTop - container.clientHeight - 200) + 'px';
            }
        });

        if (positionY > container.clientHeight) {
            endGame();
        }

        requestAnimationFrame(gameLoop);
    }
    
    // --- INITIALIZATION ---
    restartButton.addEventListener('click', resetGame);
    resetGame();
  </script>
</body>

</html>
